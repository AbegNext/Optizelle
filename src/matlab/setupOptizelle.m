% Optizelle optimization library
%
% Usage:
% global Optizelle;
% setupOptizelle();
%
function setupOptizelle()

global Optizelle

% Intialization is expensive.  Don't do it more than once.
if isempty(Optizelle) 

% Add the optizelle directory to the path, which contains a number of helper
% functions.  In theory, I could just use pwd, but I really want to know where
% *this* file is and not the current directory.
dir = mfilename('fullpath');
dir = dir(1:end-15);
dir = sprintf('%s/optizelle',dir);
addpath(dir);

% Creates an enumerated type from a cell list of names
createEnum = @(x) cell2struct( ...
    [num2cell(1:length(x)) {@(i)x{i}}], ...
    [x,{'to_string'}],2);

% Reasons we stop the Krylov method
Optizelle.KrylovStop = createEnum( { ...
    'NegativeCurvature', ...
    'RelativeErrorSmall', ...
    'MaxItersExceeded', ...
    'TrustRegionViolated', ...
    'Instability', ...
    'InvalidTrustRegionCenter' } );

% Which algorithm Optizelle.do we use
Optizelle.AlgorithmClass = createEnum( { ...
    'TrustRegion', ...
    'LineSearch', ...
    'UserDefined' } );

% Reasons why we stop the algorithm
Optizelle.StoppingCondition = createEnum( { ...
    'NotConverged', ...
    'RelativeGradientSmall', ...
    'RelativeStepSmall', ...
    'MaxItersExceeded', ...
    'InteriorPointInstability', ...
    'UserDefined' } );

% Various operators for both Hessian approximations and preconditioners
Optizelle.Operators = createEnum( { ...
    'Identity', ...
    'ScaledIdentity', ...
    'BFGS', ...
    'InvBFGS', ...
    'SR1', ...
    'InvSR1', ...
    'UserDefined' } );
    
% Different kinds of search directions
Optizelle.LineSearchDirection = createEnum( { ...
    'SteepestDescent', ...
    'FletcherReeves', ...
    'PolakRibiere', ...
    'HestenesStiefel', ...
    'BFGS', ...
    'NewtonCG' } );
   
% Different sorts of line searches
Optizelle.LineSearchKind = createEnum( { ...
    'Brents', ...
    'GoldenSection', ...
    'BackTracking', ...
    'TwoPointA', ...
    'TwoPointB' } );
    
% Different points in the optimization algorithm
Optizelle.OptimizationLocation = createEnum( { ...
    'BeginningOfOptimization', ...
    'BeforeInitialFuncAndGrad', ...
    'AfterInitialFuncAndGrad', ...
    'BeforeOptimizationLoop', ...
    'BeginningOfOptimizationLoop', ...
    'BeforeSaveOld', ...
    'BeforeStep', ...
    'BeforeGetStep', ...
    'GetStep', ...
    'AfterStepBeforeGradient', ...
    'AfterGradient', ...
    'BeforeQuasi', ...
    'AfterQuasi', ...
    'AfterCheckStop', ...
    'EndOfOptimizationIteration', ...
    'BeforeLineSearch', ...
    'AfterRejectedTrustRegion', ...
    'AfterRejectedLineSearch', ...
    'BeforeActualVersusPredicted', ...
    'EndOfKrylovIteration', ...
    'EndOfOptimization' } );

% Different problem classes
Optizelle.ProblemClass = createEnum( { ...
    'Unconstrained', ...
    'EqualityConstrained', ...
    'InequalityConstrained', ...
    'Constrained' } );
    
% Different truncated Krylov solvers
Optizelle.KrylovSolverTruncated = createEnum( { ...
    'ConjugateDirection', ...
    'MINRES' } );

% Different kinds of interior point methods
Optizelle.InteriorPointMethod = createEnum( { ...
    'PrimalDual', ...
    'PrimalDualLinked', ...
    'LogBarrier' } );
    
% Different schemes for adjusting the interior point centrality
Optizelle.CentralityStrategy = createEnum( { ...
    'Constant', ...
    'StairStep', ...
    'PredictorCorrector' } );

% Different function diagnostics on the optimization functions 
Optizelle.FunctionDiagnostics = createEnum( { ...
    'NoDiagnostics', ...
    'FirstOrder', ...
    'SecondOrder' } );

% When and how often we compute our intrusive diagnostics
Optizelle.DiagnosticScheme = createEnum( { ...
    'Never', ...
    'DiagnosticsOnly', ...
    'EveryIteration' } );

%---ScalarValuedFunction0---
% A simple scalar valued function interface, f : X -> R
err_svf=@(x)error(sprintf( ...
    'The %s function is not defined in a ScalarValuedFunction.',x));
Optizelle.ScalarValuedFunction = struct( ...
    'eval',@(x)err_svf('eval'), ...
    'grad',@(x)err_svf('grad'), ...
    'hess_vec',@(x,dx)err_svf('hess_vec'));
%---ScalarValuedFunction1---

%---VectorValuedFunction0---
% A vector valued function interface, f : X -> Y
err_vvf=@(x)error(sprintf( ...
    'The %s function is not defined in a VectorValuedFunction.',x));
Optizelle.VectorValuedFunction = struct( ...
    'eval',@(x)err_vvf('eval'), ...
    'p',@(x,dx)err_vvf('p'), ...
    'ps',@(x,dy)err_vvf('ps'), ...
    'pps',@(x,dx,dy)err_vvf('pps'));
%---VectorValuedFunction1---

%---Operator0---
% A linear operator specification, A : X->Y 
err_op=@(x)error(sprintf( ...
    'The %s function is not defined in an Operator.',x));
Optizelle.Operator = struct( ...
    'eval',@(state,x)err_op('eval'));
%---Operator1---

%---Messaging0---
% Defines how we output messages to the user
Optizelle.Messaging = struct( ...
    'print',@(x)fprintf('%s\n',x), ...
    'error',@(x)error(x));
%---Messaging1---

%---StateManipulator0---
% A function that has free reign to manipulate or analyze the state.
Optizelle.StateManipulator = struct('eval',@(fns,state,loc)state);
%---StateManipulator1---

% Vector space for the nonnegative orthant.  For basic vectors in R^m, use this.
Optizelle.Rm = struct( ...
    'init',@(x)x, ...
    'copy',@(x)x, ...
    'scal',@(alpha,x)alpha*x, ...
    'zero',@(x)zeros(size(x)), ...
    'axpy',@(alpha,x,y)alpha*x+y, ...
    'innr',@(x,y)x'*y, ...
    'rand',@(x)randn(size(x)), ...
    'prod',@(x,y)x.*y, ...
    'id',@(x)ones(size(x)), ...
    'linv',@(x,y)y./x, ...
    'barr',@(x)sum(log(x)), ...
    'srch',@(x,y) feval(@(z)min([min(z(find(z>0)));inf]),-y./x), ...
    'symm',@(x)x);

% Converts a vector to a JSON formatted string
Optizelle.json.Serialization.serialize = @serialize;

% Serializes a matlab column vector for the vector space Optizelle.Rm
Optizelle.json.Serialization.serialize( ...
    'register', ...
    @(x,name,iter)strrep(mat2str(x'),' ',', '), ...
    @(x)isvector(x) && isnumeric(x));

% Converts a JSON formatted string to a vector 
Optizelle.json.Serialization.deserialize = @deserialize;

% Deserializes a matlab column vector for the vector space Optizelle.Rm
Optizelle.json.Serialization.deserialize( ...
    'register', ...
    @(x,x_json)str2num(x_json)', ...
    @(x)isvector(x) && isnumeric(x));

%Creates an unconstrained state
Optizelle.Unconstrained.State.t = @UnconstrainedStateCreate;

% All the functions required by an optimization algorithm
Optizelle.Unconstrained.Functions.t= struct( ...
    'f',Optizelle.ScalarValuedFunction, ...
    'PH',Optizelle.Operator);

% Solves an unconstrained optimization problem
Optizelle.Unconstrained.Algorithms.getMin = @UnconstrainedAlgorithmsGetMin;

% Holds restart information
Optizelle.Unconstrained.Restart.X_Vectors = {};
Optizelle.Unconstrained.Restart.Reals = {};
Optizelle.Unconstrained.Restart.Naturals = {};
Optizelle.Unconstrained.Restart.Params = {};

% Release the state in an unconstrained optimization problem 
Optizelle.Unconstrained.Restart.release = @UnconstrainedRestartRelease;

% Capture the state in an unconstrained optimization problem 
Optizelle.Unconstrained.Restart.capture = @UnconstrainedRestartCapture;

% Reads unconstrained state parameters from file 
Optizelle.json.Unconstrained.read = @UnconstrainedStateReadJson;

% Writes a json restart file
Optizelle.json.Unconstrained.write_restart = @UnconstrainedRestartWriteRestart;

% Reads a json restart file
Optizelle.json.Unconstrained.read_restart = @UnconstrainedRestartReadRestart;

%Creates an equality constrained state
Optizelle.EqualityConstrained.State.t = @EqualityConstrainedStateCreate;

% All the functions required by an optimization algorithm
Optizelle.EqualityConstrained.Functions.t= mergeStruct( ...
    Optizelle.Unconstrained.Functions.t, ...
    struct( ...
        'g',Optizelle.VectorValuedFunction, ...
        'PSchur_left',Optizelle.Operator, ...
        'PSchur_right',Optizelle.Operator));

% Solves an equality constrained optimization problem
Optizelle.EqualityConstrained.Algorithms.getMin = ...
    @EqualityConstrainedAlgorithmsGetMin;

% Holds restart information
Optizelle.EqualityConstrained.Restart.X_Vectors = {};
Optizelle.EqualityConstrained.Restart.Y_Vectors = {};
Optizelle.EqualityConstrained.Restart.Reals = {};
Optizelle.EqualityConstrained.Restart.Naturals = {};
Optizelle.EqualityConstrained.Restart.Params = {};

% Release the state in an equality constrained optimization problem 
Optizelle.EqualityConstrained.Restart.release = ...
    @EqualityConstrainedRestartRelease;

% Capture the state in an equality constrained optimization problem 
Optizelle.EqualityConstrained.Restart.capture = ...
    @EqualityConstrainedRestartCapture;

% Reads equality constrained state parameters from file 
Optizelle.json.EqualityConstrained.read = @EqualityConstrainedStateReadJson;

% Writes a json restart file
Optizelle.json.EqualityConstrained.write_restart = ...
    @EqualityConstrainedRestartWriteRestart;

% Reads a json restart file
Optizelle.json.EqualityConstrained.read_restart = ...
    @EqualityConstrainedRestartReadRestart;

%Creates an inequality constrained state
Optizelle.InequalityConstrained.State.t = @InequalityConstrainedStateCreate;

% All the functions required by an optimization algorithm
Optizelle.InequalityConstrained.Functions.t= mergeStruct( ...
    Optizelle.Unconstrained.Functions.t, ...
    struct( ...
        'h',Optizelle.VectorValuedFunction));

% Solves an inequality constrained optimization problem
Optizelle.InequalityConstrained.Algorithms.getMin = ...
    @InequalityConstrainedAlgorithmsGetMin;

% Holds restart information
Optizelle.InequalityConstrained.Restart.X_Vectors = {};
Optizelle.InequalityConstrained.Restart.Z_Vectors = {};
Optizelle.InequalityConstrained.Restart.Reals = {};
Optizelle.InequalityConstrained.Restart.Naturals = {};
Optizelle.InequalityConstrained.Restart.Params = {};

% Release the state in an inequality constrained optimization problem 
Optizelle.InequalityConstrained.Restart.release = ...
    @InequalityConstrainedRestartRelease;

% Capture the state in an inequality constrained optimization problem 
Optizelle.InequalityConstrained.Restart.capture = ...
    @InequalityConstrainedRestartCapture;

% Reads inequality constrained state parameters from file 
Optizelle.json.InequalityConstrained.read = @InequalityConstrainedStateReadJson;

% Writes a json restart file
Optizelle.json.InequalityConstrained.write_restart = ...
    @InequalityConstrainedRestartWriteRestart;

% Reads a json restart file
Optizelle.json.InequalityConstrained.read_restart = ...
    @InequalityConstrainedRestartReadRestart;

%Creates a constrained state
Optizelle.Constrained.State.t = @ConstrainedStateCreate;

% All the functions required by an optimization algorithm
Optizelle.Constrained.Functions.t= ...
    mergeStruct( ...
        mergeStruct( ...
            Optizelle.Unconstrained.Functions.t, ...
            Optizelle.EqualityConstrained.Functions.t), ...
        Optizelle.InequalityConstrained.Functions.t);

% Solves a constrained optimization problem
Optizelle.Constrained.Algorithms.getMin = @ConstrainedAlgorithmsGetMin;

% Holds restart information
Optizelle.Constrained.Restart.X_Vectors = {};
Optizelle.Constrained.Restart.Y_Vectors = {};
Optizelle.Constrained.Restart.Z_Vectors = {};
Optizelle.Constrained.Restart.Reals = {};
Optizelle.Constrained.Restart.Naturals = {};
Optizelle.Constrained.Restart.Params = {};

% Release the state in a constrained optimization problem 
Optizelle.Constrained.Restart.release = @ConstrainedRestartRelease;

% Capture the state in a constrained optimization problem 
Optizelle.Constrained.Restart.capture = @ConstrainedRestartCapture;

% Reads constrained state parameters from file 
Optizelle.json.Constrained.read = @ConstrainedStateReadJson;

% Writes a json restart file
Optizelle.json.Constrained.write_restart = @ConstrainedRestartWriteRestart;

% Reads a json restart file
Optizelle.json.Constrained.read_restart = @ConstrainedRestartReadRestart;
end

end

% Merges two structures
function ret=mergeStruct(s1,s2)
    % Find the field names and data 
    data = [struct2cell(s1)' struct2cell(s2)'];
    fields = [fieldnames(s1)' fieldnames(s2)'];

    % Figure out the unique elements
    [fields i] = unique(fields);

    % Merge the unique elements
    ret=cell2struct(data(i),fields,2);
end
