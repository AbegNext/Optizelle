% Optielle optimization library
%
% Optizelle = setupOptizelle ()
%
function Optizelle=setupOptizelle()

% Add the optizelle directory to the path, which contains a number of helper
% functions.  In theory, I could just use pwd, but I really want to know where
% *this* file is and not the current directory.
dir = mfilename('fullpath');
dir = dir(1:end-15);
dir = sprintf('%s/optizelle',dir);
addpath(dir);

% Creates an enumerated type from a cell list of names
createEnum = @(x)struct(feval(
    @(y)y{:}, ...
    {x{:};feval( ...
        @(z)z{:}, ...
        num2cell(1:length(x)))}), ...
    'toString',@(i)x{i});

% Reasons we stop the Krylov method
Optizelle.KrylovStop = createEnum( { ...
    'NegativeCurvature', ...
    'RelativeErrorSmall', ...
    'MaxItersExceeded', ...
    'TrustRegionViolated', ...
    'Instability', ...
    'InvalidTrustRegionCenter' } );

% Which algorithm Optizelle.do we use
Optizelle.AlgorithmClass = createEnum( { ...
    'TrustRegion', ...
    'LineSearch', ...
    'UserDefined' } );

% Reasons why we stop the algorithm
Optizelle.StoppingCondition = createEnum( { ...
    'NotConverged', ...
    'RelativeGradientSmall', ...
    'RelativeStepSmall', ...
    'MaxItersExceeded', ...
    'InteriorPointInstability', ...
    'UserDefined' } );

% Various operators for both Hessian approximations and preconditioners
Optizelle.Operators = createEnum( { ...
    'Identity', ...
    'ScaledIdentity', ...
    'BFGS', ...
    'InvBFGS', ...
    'SR1', ...
    'InvSR1', ...
    'UserDefined' } );
    
% Different kinds of search directions
Optizelle.LineSearchDirection = createEnum( { ...
    'SteepestDescent', ...
    'FletcherReeves', ...
    'PolakRibiere', ...
    'HestenesStiefel', ...
    'BFGS', ...
    'NewtonCG' } );
   
% Different sorts of line searches
Optizelle.LineSearchKind = createEnum( { ...
    'Brents', ...
    'GoldenSection', ...
    'BackTracking', ...
    'TwoPointA', ...
    'TwoPointB' } );
    
% Different points in the optimization algorithm
Optizelle.OptimizationLocation = createEnum( { ...
    'BeginningOfOptimization', ...
    'BeforeInitialFuncAndGrad', ...
    'AfterInitialFuncAndGrad', ...
    'BeforeOptimizationLoop', ...
    'BeginningOfOptimizationLoop', ...
    'BeforeSaveOld', ...
    'BeforeStep', ...
    'BeforeGetStep', ...
    'GetStep', ...
    'AfterStepBeforeGradient', ...
    'AfterGradient', ...
    'BeforeQuasi', ...
    'AfterQuasi', ...
    'EndOfOptimizationIteration', ...
    'BeforeLineSearch', ...
    'AfterRejectedTrustRegion', ...
    'AfterRejectedLineSearch', ...
    'BeforeActualVersusPredicted', ...
    'EndOfKrylovIteration', ...
    'EndOfOptimization' } );

% Different problem classes
Optizelle.ProblemClass = createEnum( { ...
    'Unconstrained', ...
    'EqualityConstrained', ...
    'InequalityConstrained', ...
    'Constrained' } );
    
% Different truncated Krylov solvers
Optizelle.KrylovSolverTruncated = createEnum( { ...
    'ConjugateDirection', ...
    'MINRES' } );

% Different kinds of interior point methods
Optizelle.InteriorPointMethod = createEnum( { ...
    'PrimalDual', ...
    'PrimalDualLinked', ...
    'LogBarrier' } );
    
% Different schemes for adjusting the interior point centrality
Optizelle.CentralityStrategy = createEnum( { ...
    'Constant', ...
    'StairStep', ...
    'PredictorCorrector' } );

% Different function diagnostics on the optimization functions 
Optizelle.FunctionDiagnostics = createEnum( { ...
    'NoDiagnostics', ...
    'FirstOrder', ...
    'SecondOrder' } );

% When and how often we compute our intrusive diagnostics
Optizelle.DiagnosticScheme = createEnum( { ...
    'Never', ...
    'DiagnosticsOnly', ...
    'EveryIteration' } );

% A simple scalar valued function interface, f : X -> R
err_svf=@(x)error(sprintf( ...
    'The %s function is not defined in a ScalarValuedFunction.',x));
Optizelle.ScalarValuedFunction = struct( ...
    'eval',@(x)err_svf('eval'), ...
    'grad',@(x)err_svf('grad'), ...
    'hess_vec',@(x,dx)err_svf('hess_vec'));

% A vector valued function interface, f : X -> Y
err_vvf=@(x)error(sprintf( ...
    'The %s function is not defined in a VectorValuedFunction.',x));
Optizelle.VectorValuedFunction = struct( ...
    'eval',@(x)err_vvf('eval'),
    'p',@(x,dx)err_vvf('p'),
    'ps',@(x,dy)err_vvf('ps'),
    'pps',@(x,dx,dy)err_vvf('pps'));

% A linear operator specification, A : X->Y 
err_op=@(x)error(sprintf( ...
    'The %s function is not defined in an Operator.',x));
Optizelle.Operator = struct( ...
    'eval',@(x)err_op('eval'));

% Defines how we output messages to the user
Optizelle.Messaging = struct( ...
    'print',@(x)fprintf('%s\n',x), ...
    'error',@(x)error(x));

% A function that has free reign to manipulate or analyze the state.  This 
% should be used cautiously. 
Optizelle.StateManipulator = struct( ...
    'eval',@(x)x);

% Vector space for the nonnegative orthant.  For basic vectors in R^m, use this.
Optizelle.Rm = struct( ...
    'init',@(x)x, ...
    'copy',@(x)x, ...
    'scal',@(alpha,x)alpha*x, ...
    'zero',@(x)zeros(size(x)), ...
    'axpy',@(alpha,x,y)alpha*x+y, ...
    'innr',@(x,y)x'*y, ...
    'rand',@(x)randn(size(x)), ...
    'prod',@(x,y)x.*y, ...
    'id',@(x)ones(size(x)), ...
    'linv',@(x,y)y./x, ...
    'barr',@(x)sum(log(x)), ...
    'srch',@(x,y) feval(@(z)min([min(z(find(z>0)));inf]),-y./x), ...
    'symm',@(x)x);
